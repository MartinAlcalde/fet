<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Functional Ear Training</title>
<style>
  body { font-family: system-ui, sans-serif; max-width: 520px; margin: 32px auto; }
  h1 { font-size: 1.2rem; margin-bottom: 8px; }
  .row { display: flex; gap: 8px; margin: 12px 0; flex-wrap: wrap; }
  button { padding: 10px 14px; font-size: 16px; }
  .stat { margin-top: 8px; font-size: 14px; color: #333; }
  .feedback { height: 24px; margin-top: 8px; font-weight: 600; }

  /* Piano UI */
  .piano {
    --white-w: 64px; --white-h: 160px;
    --black-w: 36px; --black-h: 100px;
    --gap: 2px;
    position: relative; display: flex; gap: var(--gap); user-select: none; margin-top: 10px;
    overflow-x: auto; padding-bottom: 4px;
  }
  .piano.disabled { pointer-events: none; opacity: 0.7; }
  .key { position: relative; cursor: pointer; }
  .key.white { width: var(--white-w); height: var(--white-h); background: #fff; border: 1px solid #ccc; box-shadow: inset 0 -2px 0 rgba(0,0,0,0.06); }
  .key.black {
    position: absolute;
    top: 0;
    width: var(--black-w); height: var(--black-h);
    background: #111; border: 1px solid #000; z-index: 2; border-radius: 0 0 3px 3px;
  }
  .key.black::after { content: ""; position: absolute; inset: 0; box-shadow: inset 0 -2px 0 rgba(255,255,255,0.06); }
  .key.active { outline: 2px solid #3b82f6; }
  .key.correct { box-shadow: 0 0 0 2px #16a34a inset; }
  .key.wrong { box-shadow: 0 0 0 2px #dc2626 inset; }
  .key.hint { box-shadow: 0 0 0 2px #f59e0b inset; }
  .key .label { position: absolute; left: 0; right: 0; bottom: 4px; text-align: center; font-size: 12px; pointer-events: none; }
  .key.white .label { color: #222; }
  .key.black .label { color: #eee; text-shadow: 0 1px 1px rgba(0,0,0,0.6); bottom: 6px; font-size: 11px; }
  .key.white.in-scope { background: #fffbea; border-color: #f59e0b; }
  .key.white.out-of-scope { opacity: 0.85; cursor: default; }

  @media (max-width: 480px) {
    .piano { --white-w: 44px; --white-h: 132px; --black-w: 28px; --black-h: 84px; --gap: 2px; }
    .key .label { font-size: 11px; }
    .key.black .label { font-size: 10px; }
  }
  @media (max-width: 360px) {
    .piano { --white-w: 38px; --white-h: 116px; --black-w: 24px; --black-h: 74px; --gap: 2px; }
  }

  /* Key mapping panel */
  .panel { border: 1px solid #ddd; padding: 8px; border-radius: 6px; }
  .hidden { display: none; }
  .map-grid { display: grid; grid-template-columns: 1fr auto auto auto; gap: 6px 10px; align-items: center; }
  .map-row { padding: 2px 0; }
  .map-note { font-weight: 600; }
  .map-key { min-width: 24px; text-align: center; font-family: ui-monospace, monospace; }
</style>
</head>
<body>
  <h1>Functional Ear Training</h1>
  <div class="row">
    <button id="start">Start / Next</button>
    <button id="repeat">Repeat</button>
    <button id="settingsBtn" title="Settings">⚙️</button>
  </div>
  <div id="settingsPanel" class="panel hidden" aria-label="Settings">
    <div class="row" style="margin-top: 0; align-items: center; gap: 14px;">
      <label><input type="checkbox" id="resolve" checked /> Resolve to C</label>
      <label><input type="checkbox" id="solfege" checked /> Solfege labels (Do Re)</label>
      <label>Exercise:
        <select id="exercise">
          <option value="1">Ex 1 – C to F</option>
          <option value="2">Ex 2 – G to C (next)</option>
          <option value="3">Ex 3 – Full octave (C–C)</option>
        </select>
      </label>
    </div>
    <div style="margin-top: 8px; font-weight: 600;">Key Mapping</div>
    <div class="map-grid" id="mapGrid" style="margin-top: 6px;"></div>
  </div>
  <div id="piano" class="piano" aria-label="Piano C4–C5"></div>
  <div class="feedback" id="feedback"></div>
  <div class="stat" id="stat">Attempts: 0 | Correct: 0 | Accuracy: 0%</div>

<!-- Tone.js local for offline usage -->
<script src="./assets/lib/Tone.js"></script>
<!-- Embedded base64 piano samples for file:// usage -->
<script src="./assets/piano.base64.js"></script>
<script>
(() => {
  // ---------- Audio setup ----------
  let audioCtx;
  const startAudio = () => {
    if (audioCtx) return audioCtx;
    if (typeof Tone !== "undefined" && Tone.getContext) {
      audioCtx = Tone.getContext().rawContext;
    } else {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioCtx;
  };
  let sampler; // Tone.Sampler instance (lazy)
  let samplerReady = false;

  const midiToFreq = (m) => 440 * Math.pow(2, (m - 69) / 12);
  const NOTES = {
    // Core octave center
    C4: 60, Cs4: 61, D4: 62, Ds4: 63, E4: 64, F4: 65, Fs4: 66, G4: 67, Gs4: 68, A4: 69, As4: 70, B4: 71, C5: 72,
    // Additional tones for simple triad voicings
    B3: 59, G3: 55, D5: 74
  };
  const MIDI_TO_NAME = { 55: "G3", 59: "B3", 60: "C4", 61: "C#4", 62: "D4", 63: "D#4", 64: "E4", 65: "F4", 66: "F#4", 67: "G4", 68: "G#4", 69: "A4", 70: "A#4", 71: "B4", 72: "C5", 74: "D5" };
  const PC_TO_SOLFEGE = { 0: 'do', 1: 'do#', 2: 're', 3: 're#', 4: 'mi', 5: 'fa', 6: 'fa#', 7: 'sol', 8: 'sol#', 9: 'la', 10: 'la#', 11: 'si' };
  const DEGREE_TO_SOLFEGE = { 1: 'do', 2: 're', 3: 'mi', 4: 'fa' };
  const PC_TO_LETTER = { 0: 'C', 1: 'C#', 2: 'D', 3: 'D#', 4: 'E', 5: 'F', 6: 'F#', 7: 'G', 8: 'G#', 9: 'A', 10: 'A#', 11: 'B' };
  const DEGREE_TO_LETTER = { 1: 'C', 2: 'D', 3: 'E', 4: 'F' };

  async function preloadSampler() {
    // Create and load the sampler without starting audio; ready before first click
    if (sampler || typeof Tone === "undefined") return;
    const B64 = (window.PIANO_BASE64 || {});
    sampler = new Tone.Sampler({
      // Data-URI anchors; Tone.js interpolates nearby pitches
      urls: {
        A2: B64.A2,
        A3: B64.A3,
        A4: B64.A4,
        A5: B64.A5,
        C3: B64.C3,
        C4: B64.C4,
        C5: B64.C5,
        C6: B64.C6,
      },
      release: 1.2,
      onload: () => {
        samplerReady = true;
        setFeedback("Ready. Press Start");
        setStartEnabled(true);
      },
      onerror: (e) => {
        samplerReady = false;
        setFeedback("Error cargando piano");
      }
    }).toDestination();
  }

  function playTone(midi, when, dur = 0.6, type = "sine", gainVal = 0.15) {
    // Require sample-based piano; if not ready, do nothing
    const name = MIDI_TO_NAME[midi];
    if (!(sampler && samplerReady && name)) return;
    const ctx = startAudio();
    const delay = Math.max(0, when - ctx.currentTime);
    const t = (typeof Tone !== "undefined" ? Tone.now() : 0) + delay;
    const vel = Math.max(0.05, Math.min(1, gainVal * 6));
    sampler.triggerAttackRelease(name, dur, t, vel);
  }

  function playChord(midis, when, dur = 0.7, type = "piano", chordGain = 0.24) {
    const perVoice = chordGain / Math.max(1, midis.length);
    midis.forEach(m => playTone(m, when, dur, type, perVoice));
  }

  // Cadence: I–IV–V–I in C major (simple triads with smooth voice-leading)
  function playCadence() {
    const ctx = startAudio();
    const t0 = ctx.currentTime + 0.05;
    const step = 0.65;
    // I: C major (C4 E4 G4)
    playChord([NOTES.C4, NOTES.E4, NOTES.G4], t0, step, "piano");
    // IV: F major voiced with common tone C4 (C4 F4 A4)
    playChord([NOTES.C4, NOTES.F4, NOTES.A4], t0 + step, step, "piano");
    // V: G major (B3 D4 G4) for smooth motion
    playChord([NOTES.B3, NOTES.D4, NOTES.G4], t0 + 2*step, step, "piano");
    // I: C major return
    playChord([NOTES.C4, NOTES.E4, NOTES.G4], t0 + 3*step, step, "piano");
    return t0 + 4*step; // end time
  }

  // ---------- Game state ----------
  const state = {
    running: false,
    targetMidi: null,
    attempts: 0,
    correct: 0,
    answersEnabled: false,
    notation: 'solfege',
    exercise: 1,
    keymap: {}, // key->midi
    waitingMapMidi: null,
  };

  const ui = {
    feedback: document.getElementById("feedback"),
    stat: document.getElementById("stat"),
    resolve: document.getElementById("resolve"),
    startBtn: document.getElementById("start"),
    piano: document.getElementById("piano"),
    solfege: document.getElementById("solfege"),
    exercise: document.getElementById("exercise"),
    repeatBtn: document.getElementById("repeat"),
    settingsBtn: document.getElementById("settingsBtn"),
    settingsPanel: document.getElementById("settingsPanel"),
    mapGrid: document.getElementById("mapGrid"),
  };

  function updateStats() {
    const acc = state.attempts ? Math.round((100 * state.correct) / state.attempts) : 0;
    ui.stat.textContent = `Attempts: ${state.attempts} | Correct: ${state.correct} | Accuracy: ${acc}%`;
  }

  function setFeedback(text, ok = null) {
    ui.feedback.textContent = text;
    ui.feedback.style.color = ok === null ? "#333" : ok ? "green" : "crimson";
  }

  function setPianoEnabled(on) {
    state.answersEnabled = !!on;
    ui.piano.classList.toggle('disabled', !on);
  }

  function setStartEnabled(on) {
    ui.startBtn.disabled = !on;
  }

  function setRepeatEnabled(on) {
    ui.repeatBtn.disabled = !on;
  }

  function getExerciseSet() {
    // Returns an array of allowed MIDI notes for current exercise
    switch (state.exercise) {
      case 1: return [NOTES.C4, NOTES.D4, NOTES.E4, NOTES.F4];
      case 2: return [NOTES.G4, NOTES.A4, NOTES.B4, NOTES.C5];
      case 3: return [NOTES.C4, NOTES.D4, NOTES.E4, NOTES.F4, NOTES.G4, NOTES.A4, NOTES.B4, NOTES.C5];
      default: return [NOTES.C4, NOTES.D4, NOTES.E4, NOTES.F4];
    }
  }
  function pickRandomTargetMidi() {
    const set = getExerciseSet();
    return set[Math.floor(Math.random() * set.length)];
  }

  // Start/Next cycle
  ui.startBtn.addEventListener("click", async () => {
    if (!samplerReady) {
      setFeedback("Loading piano…");
      return;
    }
    await Tone.start(); // unlock audio context on gesture
    startAudio();
    if (state.targetMidi) return; // ignore if a target is already active (awaiting answer)
    startRound();
  });

  function startRound() {
    setStartEnabled(false);
    setPianoEnabled(false);
    setRepeatEnabled(false);
    setFeedback("Cadence…", null);
    const endCad = playCadence();
    const ctx = startAudio();
    // Choose target after cadence completes
    state.targetMidi = pickRandomTargetMidi();
    const tTarget = endCad + 0.12;
    playTone(state.targetMidi, tTarget, 0.9, "piano", 0.18);
    // Enable answers slightly after target onset
    const enableAtMs = Math.max(0, (tTarget - ctx.currentTime) * 1000) + 120;
    setTimeout(() => {
      setFeedback("Identify the note (click the key)");
      setPianoEnabled(true);
      setRepeatEnabled(true);
    }, enableAtMs);
  }

  // Piano click answers
  function onPianoClick(e) {
    const keyEl = e.target.closest('[data-midi]');
    if (!keyEl || !state.answersEnabled || !state.targetMidi) return;
    const midi = Number(keyEl.dataset.midi);
    const allowed = new Set(getExerciseSet());
    if (!allowed.has(midi)) {
      setFeedback('Only notes in the highlighted range');
      flashKey(keyEl, 'wrong');
      return;
    }
    const ok = midi === state.targetMidi;
    state.attempts++;
    if (ok) state.correct++;
    const correctLabel = labelForMidi(state.targetMidi);
    setFeedback(ok ? '✓ Correct' : `✗ Wrong (it was ${correctLabel})`, ok);
    updateStats();
    flashKey(keyEl, ok ? 'correct' : 'wrong');

    if (ok) {
      // Optional resolution to C, then auto-advance to next round
      const ctx = startAudio();
      let nextDelayMs = 400; // minimal gap if no resolution
      if (ui.resolve.checked) {
        const t0 = ctx.currentTime + 0.05;
        playTone(state.targetMidi, t0, 0.45, 'piano', 0.16);
        playTone(NOTES.C4, t0 + 0.46, 0.8, 'piano', 0.18);
        const tEnd = t0 + 0.46 + 0.82; // rough end of resolution
        nextDelayMs = Math.max(0, (tEnd - ctx.currentTime) * 1000) + 120;
      }
      // Prepare for next round
      setPianoEnabled(false);
      setRepeatEnabled(false);
      state.targetMidi = null;
      setTimeout(() => {
        startRound();
      }, nextDelayMs);
    } else {
      // Stay on this round, no resolution
      // Keep piano and repeat enabled for retry
    }
  }
  ui.piano.addEventListener('click', onPianoClick);

  // Keyboard shortcuts: Enter to start, custom keymap to play
  window.addEventListener("keydown", (e) => {
    // Capture mapping assignment
    if (state.waitingMapMidi !== null) {
      e.preventDefault();
      const key = normalizeKey(e);
      if (key && !isReservedKey(key)) {
        setKeymap(state.waitingMapMidi, key);
      }
      state.waitingMapMidi = null;
      renderKeymapRows();
      return;
    }
    if (e.key === "Enter") ui.startBtn.click();
    const key = normalizeKey(e);
    if (key && state.keymap[key] != null) {
      e.preventDefault();
      clickMidi(state.keymap[key]);
    }
  });

  // Notation toggle
  ui.solfege.addEventListener('change', () => {
    state.notation = ui.solfege.checked ? 'solfege' : 'letter';
    updatePianoLabels();
    try { localStorage.setItem('fet-notation', state.notation); } catch {}
    renderKeymapRows();
  });

  // Exercise selector
  ui.exercise.addEventListener('change', () => {
    state.exercise = Number(ui.exercise.value) || 1;
    applyScopeHighlight();
    if (state.targetMidi) {
      // reset current round to avoid mismatch with new scope
      state.targetMidi = null;
      setPianoEnabled(false);
      setRepeatEnabled(false);
      setStartEnabled(true);
      setFeedback('Exercise changed. Press Start');
    }
    renderKeymapRows();
  });

  // Repeat current target (cadence + same target)
  ui.repeatBtn.addEventListener('click', () => {
    if (!state.targetMidi) return;
    // Repeat full context: cadence + same target
    setPianoEnabled(false);
    setRepeatEnabled(false);
    setFeedback('Cadence…', null);
    const endCad = playCadence();
    const ctx = startAudio();
    const tTarget = endCad + 0.12;
    playTone(state.targetMidi, tTarget, 0.9, 'piano', 0.18);
    const enableAtMs = Math.max(0, (tTarget - ctx.currentTime) * 1000) + 120;
    setTimeout(() => {
      setFeedback('Identify the note (click the key)');
      setPianoEnabled(true);
      setRepeatEnabled(true);
    }, enableAtMs);
  });

  updateStats();
  setPianoEnabled(false);
  setRepeatEnabled(false);
  // Load saved notation preference
  try {
    const saved = localStorage.getItem('fet-notation');
    if (saved === 'solfege' || saved === 'letter') {
      state.notation = saved;
      ui.solfege.checked = (saved === 'solfege');
    }
  } catch {}
  buildPiano();
  setStartEnabled(false);
  setFeedback("Loading piano…");
  // Preload samples; onload will enable Start
  preloadSampler();
  // Reposition black keys on resize (responsive)
  window.addEventListener('resize', () => {
    positionBlackKeys();
  });
  // Load/save keymap and build UI
  loadKeymap();
  renderKeymapRows();

  // ---------- Piano UI helpers ----------
  function buildPiano() {
    const whites = [NOTES.C4, NOTES.D4, NOTES.E4, NOTES.F4, NOTES.G4, NOTES.A4, NOTES.B4, NOTES.C5];
    ui.piano.innerHTML = '';
    ui.piano.className = 'piano';
    const hasSharpAfter = (midi) => {
      // Sharps after C, D, F, G, A within the octave
      const pc = midi % 12; // 0=C, 2=D, 4=E, 5=F, 7=G, 9=A, 11=B
      return pc === 0 || pc === 2 || pc === 5 || pc === 7 || pc === 9;
    };
    // First render whites
    whites.forEach((midi) => {
      const key = document.createElement('div');
      key.className = 'key white';
      key.dataset.midi = String(midi);
      key.dataset.note = MIDI_TO_NAME[midi] || '';
      const lab = document.createElement('div');
      lab.className = 'label';
      key.appendChild(lab);
      ui.piano.appendChild(key);
    });
    // Then render blacks positioned absolutely relative to the piano container
    whites.forEach((midi) => {
      if (hasSharpAfter(midi) && midi !== NOTES.C5) { // hide C#5
        const blackMidi = midi + 1;
        const black = document.createElement('div');
        black.className = 'key black';
        black.dataset.midi = String(blackMidi);
        black.dataset.note = MIDI_TO_NAME[blackMidi] || '';
        black.dataset.blackFor = String(midi); // preceding white midi
        const blab = document.createElement('div');
        blab.className = 'label';
        black.appendChild(blab);
        ui.piano.appendChild(black);
      }
    });
    applyScopeHighlight();
    updatePianoLabels();
    positionBlackKeys();
  }

  function updatePianoLabels() {
    const useSolfege = state.notation === 'solfege';
    ui.piano.querySelectorAll('[data-midi]').forEach(el => {
      const midi = Number(el.dataset.midi);
      const pc = midi % 12;
      const text = useSolfege ? (PC_TO_SOLFEGE[pc] || '') : (PC_TO_LETTER[pc] || '');
      const lab = el.querySelector('.label');
      if (lab) lab.textContent = text;
    });
  }

  function applyScopeHighlight() {
    const allowed = new Set(getExerciseSet());
    ui.piano.querySelectorAll('.key.white').forEach(el => {
      const midi = Number(el.dataset.midi);
      el.classList.toggle('in-scope', allowed.has(midi));
      el.classList.toggle('out-of-scope', !allowed.has(midi));
    });
  }

  function labelForMidi(midi) {
    const pc = midi % 12;
    return state.notation === 'solfege' ? (PC_TO_SOLFEGE[pc] || '') : (PC_TO_LETTER[pc] || '');
  }

  function positionBlackKeys() {
    const pianoRect = ui.piano.getBoundingClientRect();
    const styles = getComputedStyle(ui.piano);
    const gap = parseFloat(styles.getPropertyValue('--gap')) || 2;
    ui.piano.querySelectorAll('.key.black').forEach(black => {
      const whiteMidi = Number(black.dataset.blackFor);
      const whiteEl = ui.piano.querySelector(`.key.white[data-midi="${whiteMidi}"]`);
      if (!whiteEl) return;
      const wRect = whiteEl.getBoundingClientRect();
      const bRect = black.getBoundingClientRect();
      const left = (wRect.left - pianoRect.left) + whiteEl.offsetWidth - (black.offsetWidth / 2) + (gap / 2);
      black.style.left = `${left}px`;
    });
  }

  // ---------- Key mapping helpers ----------
  function normalizeKey(e) {
    const k = e.key;
    if (!k) return '';
    if (k.length === 1) return k.toLowerCase();
    // allow some named keys if desired; currently disallow to keep simple
    return k.toLowerCase();
  }
  function isReservedKey(k) {
    return ['enter','escape','shift','control','alt','meta','tab'].includes(k);
  }
  function setKeymap(midi, key) {
    // remove previous mapping of this key
    Object.keys(state.keymap).forEach(k => {
      if (state.keymap[k] === midi || k === key) delete state.keymap[k];
    });
    state.keymap[key] = midi;
    saveKeymap();
  }
  function clearKeymap(midi) {
    Object.keys(state.keymap).forEach(k => { if (state.keymap[k] === midi) delete state.keymap[k]; });
    saveKeymap();
  }
  function saveKeymap() {
    try { localStorage.setItem('fet-keymap', JSON.stringify(state.keymap)); } catch {}
  }
  function loadKeymap() {
    try {
      const raw = localStorage.getItem('fet-keymap');
      if (raw) {
        state.keymap = JSON.parse(raw) || {};
        return;
      }
    } catch {}
    // Default home-row mapping across the visible octave: a..k
    state.keymap = { a: NOTES.C4, s: NOTES.D4, d: NOTES.E4, f: NOTES.F4, g: NOTES.G4, h: NOTES.A4, j: NOTES.B4, k: NOTES.C5 };
    saveKeymap();
  }
  function renderKeymapRows() {
    const set = getExerciseSet();
    ui.mapGrid.innerHTML = '';
    set.forEach(midi => {
      const row = document.createElement('div');
      row.className = 'map-row map-note';
      row.textContent = labelForMidi(midi);
      const setBtn = document.createElement('button');
      setBtn.textContent = 'Set key';
      setBtn.addEventListener('click', () => {
        state.waitingMapMidi = midi;
        setFeedback(`Press a key for ${labelForMidi(midi)} (Esc to cancel)`);
      });
      const keySpan = document.createElement('div');
      keySpan.className = 'map-key';
      keySpan.textContent = keyForMidi(midi) || '—';
      const clrBtn = document.createElement('button');
      clrBtn.textContent = 'Clear';
      clrBtn.addEventListener('click', () => { clearKeymap(midi); renderKeymapRows(); });
      ui.mapGrid.appendChild(row);
      ui.mapGrid.appendChild(setBtn);
      ui.mapGrid.appendChild(keySpan);
      ui.mapGrid.appendChild(clrBtn);
    });
  }
  function keyForMidi(midi) {
    const entry = Object.entries(state.keymap).find(([k, m]) => m === midi);
    return entry ? entry[0] : '';
  }

  // Toggle settings panel
  ui.settingsBtn.addEventListener('click', () => {
    ui.settingsPanel.classList.toggle('hidden');
    renderKeymapRows();
  });

  function clickMidi(midi) {
    const el = ui.piano.querySelector(`[data-midi="${midi}"]`);
    if (el) el.click();
  }

  function flashKey(el, cls, ms = 250) {
    el.classList.add('active', cls);
    setTimeout(() => el.classList.remove('active', cls), ms);
  }

  function highlightKey(midi, ms = 300) {
    const el = ui.piano.querySelector(`[data-midi="${midi}"]`);
    if (el) flashKey(el, 'hint', ms);
  }
})();
</script>
</body>
</html>
