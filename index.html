<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Functional Ear Training</title>
<style>
  body { font-family: system-ui, sans-serif; max-width: 520px; margin: 32px auto; }
  h1 { font-size: 1.2rem; margin-bottom: 8px; }
  .row { display: flex; gap: 8px; margin: 12px 0; flex-wrap: wrap; }
  button { padding: 10px 14px; font-size: 16px; }
  .stat { margin-top: 8px; font-size: 14px; color: #333; }
  .feedback { height: 24px; margin-top: 8px; font-weight: 600; }

  /* Piano UI */
  .piano {
    --white-w: 64px; --white-h: 160px;
    --black-w: 36px; --black-h: 100px;
    --gap: 2px;
    position: relative; display: flex; gap: var(--gap); user-select: none; margin-top: 10px;
    overflow-x: auto; padding-bottom: 4px;
  }
  .piano.disabled { pointer-events: none; opacity: 0.7; }
  .key { position: relative; cursor: pointer; }
  .key.white { width: var(--white-w); height: var(--white-h); background: #fff; border: 1px solid #ccc; box-shadow: inset 0 -2px 0 rgba(0,0,0,0.06); }
  .key.black {
    position: absolute;
    top: 0;
    width: var(--black-w); height: var(--black-h);
    background: #111; border: 1px solid #000; z-index: 2; border-radius: 0 0 3px 3px;
  }
  .key.black::after { content: ""; position: absolute; inset: 0; box-shadow: inset 0 -2px 0 rgba(255,255,255,0.06); }
  .key.active { outline: 2px solid #3b82f6; }
  .key.correct { box-shadow: 0 0 0 2px #16a34a inset; }
  .key.wrong { box-shadow: 0 0 0 2px #dc2626 inset; }
  .key.hint { box-shadow: 0 0 0 2px #f59e0b inset; }
  .key .label { position: absolute; left: 0; right: 0; bottom: 4px; text-align: center; font-size: 12px; pointer-events: none; }
  .key.white .label { color: #222; }
  .key.black .label { color: #eee; text-shadow: 0 1px 1px rgba(0,0,0,0.6); bottom: 6px; font-size: 11px; }
  .key.white.in-scope { background: #fffbea; border-color: #f59e0b; }
  .key.white.out-of-scope { opacity: 0.85; cursor: default; }

  @media (max-width: 480px) {
    .piano { --white-w: 44px; --white-h: 132px; --black-w: 28px; --black-h: 84px; --gap: 2px; }
    .key .label { font-size: 11px; }
    .key.black .label { font-size: 10px; }
  }
  @media (max-width: 360px) {
    .piano { --white-w: 38px; --white-h: 116px; --black-w: 24px; --black-h: 74px; --gap: 2px; }
  }

  /* Key mapping panel */
  .panel { border: 1px solid #ddd; padding: 8px; border-radius: 6px; }
  .hidden { display: none; }
  .map-grid { display: grid; grid-template-columns: 1fr auto auto auto; gap: 6px 10px; align-items: center; }
  .map-row { padding: 2px 0; }
  .map-note { font-weight: 600; }
  .map-key { min-width: 24px; text-align: center; font-family: ui-monospace, monospace; }
  .muted { color: #6b7280; }
</style>
</head>
<body>
  <h1>Functional Ear Training</h1>
  <div class="row">
    <button id="start">Start / Next</button>
    <button id="repeat">Repeat</button>
    <button id="settingsBtn" title="Settings">‚öôÔ∏è</button>
  </div>
  <div id="settingsPanel" class="panel hidden" aria-label="Settings">
    <div class="row" style="margin-top: 0; align-items: center; gap: 14px;">
      <label><input type="checkbox" id="resolve" checked /> Resolve to C</label>
      <label><input type="checkbox" id="solfege" checked /> Solfege labels (Do Re)</label>
      <label>Exercise:
        <select id="exercise">
          <option value="1">Ex 1 ‚Äì C to F</option>
          <option value="2">Ex 2 ‚Äì G to C (next)</option>
          <option value="3">Ex 3 ‚Äì Full octave (C‚ÄìC)</option>
        </select>
      </label>
    </div>
    <div style="margin-top: 8px; font-weight: 600;">Key Mapping</div>
    <div class="map-grid" id="mapGrid" style="margin-top: 6px;"></div>
    <div style="margin-top: 10px; font-weight: 600;">BLE Remote</div>
    <div class="panel" style="margin-top: 6px; padding: 8px;">
      <div class="row" style="margin: 0; gap: 10px; align-items: center;">
        <button id="hidConnect">Connect HID</button>
        <div id="hidStatus" class="muted">Not connected</div>
      </div>
      <div class="row" style="margin: 6px 0 0 0; gap: 10px; align-items: center;">
        <button id="bluetoothConnect">üîµ Connect Bluetooth</button>
        <div id="bluetoothStatus" class="muted">Not connected</div>
      </div>
      <div class="row" style="margin: 6px 0 0 0; gap: 10px; align-items: center;">
        <button id="gamepadConnect">üéÆ Detect Gamepad</button>
        <div id="gamepadStatus" class="muted">Not detected</div>
      </div>
      <div id="hidNote" class="muted" style="margin-top: 6px; font-size: 12px;">Use Bluetooth for direct BLE access with unique button detection</div>
    </div>
    <div style="margin-top: 10px; font-weight: 600;">Key Tester</div>
    <div class="panel" style="margin-top: 6px; padding: 8px;">
      <div id="keyTestLine">Press a key or your remote‚Ä¶</div>
      <div id="keyTestDetail" class="muted" style="margin-top: 4px; font-size: 12px;"></div>
    </div>
  </div>
  <div id="piano" class="piano" aria-label="Piano C4‚ÄìC5"></div>
  <div class="feedback" id="feedback"></div>
  <div class="stat" id="stat">Attempts: 0 | Correct: 0 | Accuracy: 0%</div>

<!-- Tone.js local for offline usage -->
<script src="./assets/lib/Tone.js"></script>
<!-- Embedded base64 piano samples for file:// usage -->
<script src="./assets/piano.base64.js"></script>
<script>
(() => {
  // ---------- Audio setup ----------
  let audioCtx;
  const startAudio = () => {
    if (audioCtx) return audioCtx;
    if (typeof Tone !== "undefined" && Tone.getContext) {
      audioCtx = Tone.getContext().rawContext;
    } else {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioCtx;
  };
  let sampler; // Tone.Sampler instance (lazy)
  let samplerReady = false;

  const midiToFreq = (m) => 440 * Math.pow(2, (m - 69) / 12);
  const NOTES = {
    // Core octave center
    C4: 60, Cs4: 61, D4: 62, Ds4: 63, E4: 64, F4: 65, Fs4: 66, G4: 67, Gs4: 68, A4: 69, As4: 70, B4: 71, C5: 72,
    // Additional tones for simple triad voicings
    B3: 59, G3: 55, D5: 74
  };
  const MIDI_TO_NAME = { 55: "G3", 59: "B3", 60: "C4", 61: "C#4", 62: "D4", 63: "D#4", 64: "E4", 65: "F4", 66: "F#4", 67: "G4", 68: "G#4", 69: "A4", 70: "A#4", 71: "B4", 72: "C5", 74: "D5" };
  const PC_TO_SOLFEGE = { 0: 'do', 1: 'do#', 2: 're', 3: 're#', 4: 'mi', 5: 'fa', 6: 'fa#', 7: 'sol', 8: 'sol#', 9: 'la', 10: 'la#', 11: 'si' };
  const DEGREE_TO_SOLFEGE = { 1: 'do', 2: 're', 3: 'mi', 4: 'fa' };
  const PC_TO_LETTER = { 0: 'C', 1: 'C#', 2: 'D', 3: 'D#', 4: 'E', 5: 'F', 6: 'F#', 7: 'G', 8: 'G#', 9: 'A', 10: 'A#', 11: 'B' };
  const DEGREE_TO_LETTER = { 1: 'C', 2: 'D', 3: 'E', 4: 'F' };

  async function preloadSampler() {
    // Create and load the sampler without starting audio; ready before first click
    if (sampler || typeof Tone === "undefined") return;
    const B64 = (window.PIANO_BASE64 || {});
    sampler = new Tone.Sampler({
      // Data-URI anchors; Tone.js interpolates nearby pitches
      urls: {
        A2: B64.A2,
        A3: B64.A3,
        A4: B64.A4,
        A5: B64.A5,
        C3: B64.C3,
        C4: B64.C4,
        C5: B64.C5,
        C6: B64.C6,
      },
      release: 1.2,
      onload: () => {
        samplerReady = true;
        setFeedback("Ready. Press Start");
        setStartEnabled(true);
      },
      onerror: (e) => {
        samplerReady = false;
        setFeedback("Error cargando piano");
      }
    }).toDestination();
  }

  function playTone(midi, when, dur = 0.6, type = "sine", gainVal = 0.15) {
    // Require sample-based piano; if not ready, do nothing
    const name = MIDI_TO_NAME[midi];
    if (!(sampler && samplerReady && name)) return;
    const ctx = startAudio();
    const delay = Math.max(0, when - ctx.currentTime);
    const t = (typeof Tone !== "undefined" ? Tone.now() : 0) + delay;
    const vel = Math.max(0.05, Math.min(1, gainVal * 6));
    sampler.triggerAttackRelease(name, dur, t, vel);
  }

  function playChord(midis, when, dur = 0.7, type = "piano", chordGain = 0.24) {
    const perVoice = chordGain / Math.max(1, midis.length);
    midis.forEach(m => playTone(m, when, dur, type, perVoice));
  }

  // Cadence: I‚ÄìIV‚ÄìV‚ÄìI in C major (simple triads with smooth voice-leading)
  function playCadence() {
    const ctx = startAudio();
    const t0 = ctx.currentTime + 0.05;
    const step = 0.65;
    // I: C major (C4 E4 G4)
    playChord([NOTES.C4, NOTES.E4, NOTES.G4], t0, step, "piano");
    // IV: F major voiced with common tone C4 (C4 F4 A4)
    playChord([NOTES.C4, NOTES.F4, NOTES.A4], t0 + step, step, "piano");
    // V: G major (B3 D4 G4) for smooth motion
    playChord([NOTES.B3, NOTES.D4, NOTES.G4], t0 + 2*step, step, "piano");
    // I: C major return
    playChord([NOTES.C4, NOTES.E4, NOTES.G4], t0 + 3*step, step, "piano");
    return t0 + 4*step; // end time
  }

  // ---------- Game state ----------
  const state = {
    running: false,
    targetMidi: null,
    attempts: 0,
    correct: 0,
    answersEnabled: false,
    notation: 'solfege',
    exercise: 1,
    keymap: {}, // key->midi
    waitingMapMidi: null,
    bluetoothDevice: null,
    bluetoothCharacteristic: null,
    gamepadIndex: -1,
    gamepadButtons: [],
    gamepadAxes: [],
    axisThreshold: 0.5,
  };

  const ui = {
    feedback: document.getElementById("feedback"),
    stat: document.getElementById("stat"),
    resolve: document.getElementById("resolve"),
    startBtn: document.getElementById("start"),
    piano: document.getElementById("piano"),
    solfege: document.getElementById("solfege"),
    exercise: document.getElementById("exercise"),
    repeatBtn: document.getElementById("repeat"),
    settingsBtn: document.getElementById("settingsBtn"),
    settingsPanel: document.getElementById("settingsPanel"),
    mapGrid: document.getElementById("mapGrid"),
    keyTestLine: document.getElementById("keyTestLine"),
    keyTestDetail: document.getElementById("keyTestDetail"),
    hidConnect: document.getElementById("hidConnect"),
    hidStatus: document.getElementById("hidStatus"),
    hidNote: document.getElementById("hidNote"),
    bluetoothConnect: document.getElementById("bluetoothConnect"),
    bluetoothStatus: document.getElementById("bluetoothStatus"),
    gamepadConnect: document.getElementById("gamepadConnect"),
    gamepadStatus: document.getElementById("gamepadStatus"),
  };

  function updateStats() {
    const acc = state.attempts ? Math.round((100 * state.correct) / state.attempts) : 0;
    ui.stat.textContent = `Attempts: ${state.attempts} | Correct: ${state.correct} | Accuracy: ${acc}%`;
  }

  function setFeedback(text, ok = null) {
    ui.feedback.textContent = text;
    ui.feedback.classList.remove('ok','err');
    if (ok === true) ui.feedback.classList.add('ok');
    if (ok === false) ui.feedback.classList.add('err');
  }

  function setPianoEnabled(on) {
    state.answersEnabled = !!on;
    ui.piano.classList.toggle('disabled', !on);
  }

  function setStartEnabled(on) {
    ui.startBtn.disabled = !on;
  }

  function setRepeatEnabled(on) {
    ui.repeatBtn.disabled = !on;
  }

  function getExerciseSet() {
    // Returns an array of allowed MIDI notes for current exercise
    switch (state.exercise) {
      case 1: return [NOTES.C4, NOTES.D4, NOTES.E4, NOTES.F4];
      case 2: return [NOTES.G4, NOTES.A4, NOTES.B4, NOTES.C5];
      case 3: return [NOTES.C4, NOTES.D4, NOTES.E4, NOTES.F4, NOTES.G4, NOTES.A4, NOTES.B4, NOTES.C5];
      default: return [NOTES.C4, NOTES.D4, NOTES.E4, NOTES.F4];
    }
  }
  function pickRandomTargetMidi() {
    const set = getExerciseSet();
    return set[Math.floor(Math.random() * set.length)];
  }

  // Start/Next cycle
  ui.startBtn.addEventListener("click", async () => {
    if (!samplerReady) {
      setFeedback("Loading piano‚Ä¶");
      return;
    }
    await Tone.start(); // unlock audio context on gesture
    startAudio();
    if (state.targetMidi) return; // ignore if a target is already active (awaiting answer)
    startRound();
  });

  function startRound() {
    setStartEnabled(false);
    setPianoEnabled(false);
    setRepeatEnabled(false);
    setFeedback("Cadence‚Ä¶", null);
    const endCad = playCadence();
    const ctx = startAudio();
    // Choose target after cadence completes
    state.targetMidi = pickRandomTargetMidi();
    const tTarget = endCad + 0.12;
    playTone(state.targetMidi, tTarget, 0.9, "piano", 0.18);
    // Enable answers slightly after target onset
    const enableAtMs = Math.max(0, (tTarget - ctx.currentTime) * 1000) + 120;
    setTimeout(() => {
      setFeedback("Identify the note (click the key)");
      setPianoEnabled(true);
      setRepeatEnabled(true);
    }, enableAtMs);
  }

  // Piano click answers
  function onPianoClick(e) {
    const keyEl = e.target.closest('[data-midi]');
    if (!keyEl || !state.answersEnabled || !state.targetMidi) return;
    const midi = Number(keyEl.dataset.midi);
    const allowed = new Set(getExerciseSet());
    if (!allowed.has(midi)) {
      setFeedback('Only notes in the highlighted range');
      flashKey(keyEl, 'wrong');
      return;
    }
    const ok = midi === state.targetMidi;
    state.attempts++;
    if (ok) state.correct++;
    const correctLabel = labelForMidi(state.targetMidi);
    setFeedback(ok ? '‚úì Correct' : `‚úó Wrong (it was ${correctLabel})`, ok);
    updateStats();
    flashKey(keyEl, ok ? 'correct' : 'wrong');

    if (ok) {
      // Optional resolution to C, then auto-advance to next round
      const ctx = startAudio();
      let nextDelayMs = 400; // minimal gap if no resolution
      if (ui.resolve.checked) {
        const t0 = ctx.currentTime + 0.05;
        playTone(state.targetMidi, t0, 0.45, 'piano', 0.16);
        playTone(NOTES.C4, t0 + 0.46, 0.8, 'piano', 0.18);
        const tEnd = t0 + 0.46 + 0.82; // rough end of resolution
        nextDelayMs = Math.max(0, (tEnd - ctx.currentTime) * 1000) + 120;
      }
      // Prepare for next round
      setPianoEnabled(false);
      setRepeatEnabled(false);
      state.targetMidi = null;
      setTimeout(() => {
        startRound();
      }, nextDelayMs);
    } else {
      // Stay on this round, no resolution
      // Keep piano and repeat enabled for retry
    }
  }
  ui.piano.addEventListener('click', onPianoClick);

  // Keyboard shortcuts: Enter to start, custom keymap to play
  window.addEventListener("keydown", (e) => {
    // Key tester output
    try {
      const key = (e.key || '');
      const code = (e.code || '');
      const keyCode = e.keyCode || e.which;
      
      // Enhanced display for unidentified keys
      if (key === 'unidentified' || key === '') {
        if (ui.keyTestLine) {
          ui.keyTestLine.textContent = `Unidentified Key | Code: ${keyCode || '‚Äî'} | Location: ${e.location || 0}`;
        }
      } else {
        if (ui.keyTestLine) {
          ui.keyTestLine.textContent = `Key: ${key || '‚Äî'} | Code: ${code || '‚Äî'}`;
        }
      }
      
      // Resolve mapping: check ids function if present
      let mappedMidi = null;
      if (typeof idsFromEvent === 'function') {
        const ids = idsFromEvent(e);
        for (const id of ids) { 
          if (state.keymap[id] != null) { 
            mappedMidi = state.keymap[id]; 
            break; 
          } 
        }
        
        // Show all possible IDs for debugging
        if (ui.keyTestDetail) {
          if (mappedMidi) {
            ui.keyTestDetail.textContent = `Mapped to: ${labelForMidi(mappedMidi)}`;
          } else {
            ui.keyTestDetail.textContent = `IDs: ${ids.join(', ')} | No mapping`;
          }
        }
      }
    } catch {}

    // Capture mapping assignment
    if (state.waitingMapMidi !== null) {
      e.preventDefault();
      if (e.key === 'Escape') { state.waitingMapMidi = null; setFeedback('Mapping cancelled'); return; }
      setKeymapFromEvent(state.waitingMapMidi, e);
      state.waitingMapMidi = null;
      renderKeymapRows();
      return;
    }
    if (e.key === "Enter") ui.startBtn.click();
    const ids = idsFromEvent(e);
    for (const id of ids) {
      if (state.keymap[id] != null) {
        e.preventDefault();
        clickMidi(state.keymap[id]);
        break;
      }
    }
  });

  // ---------- WebHID support for BLE shutter remotes ----------
  const hid = navigator.hid;
  if (ui.hidNote) {
    if (!hid || !window.isSecureContext) {
      ui.hidNote.textContent = 'WebHID requires a secure context (https or localhost). Open this page via http://localhost to connect a remote.';
    } else {
      ui.hidNote.textContent = 'Click Connect Remote to pair your shutter. Then press a button to test or map it.';
    }
  }
  if (ui.hidConnect) {
    ui.hidConnect.disabled = !(hid && window.isSecureContext);
    ui.hidConnect.addEventListener('click', async () => {
      if (!hid || !window.isSecureContext) return;
      try {
        // Expanded filters for better BLE shutter compatibility
        const filters = [
          { usagePage: 0x0C }, // Consumer Control (volume, play/pause)
          { usagePage: 0x01, usage: 0x06 }, // Keyboard
          { usagePage: 0x01, usage: 0x02 }, // Mouse
          { usagePage: 0x01, usage: 0x80 }, // System Control
          // No filter to catch all devices (comment out if too broad)
          // {}
        ];
        console.log('Requesting HID device...');
        const devices = await hid.requestDevice({ filters });
        console.log('Selected devices:', devices);
        
        if (!devices || devices.length === 0) {
          ui.hidStatus.textContent = 'No device selected';
          return;
        }
        
        for (const d of devices) {
          console.log('Device info:', {
            vendorId: d.vendorId?.toString(16),
            productId: d.productId?.toString(16),
            productName: d.productName
          });
          
          await d.open().catch((err) => {
            console.error('Failed to open device:', err);
          });
          d.addEventListener('inputreport', onHidReport);
        }
        ui.hidStatus.textContent = `Connected: ${devices.length} device(s)`;
      } catch (err) {
        console.error('HID connection error:', err);
        ui.hidStatus.textContent = `Failed: ${err.message}`;
      }
    });
    if (hid) {
      hid.addEventListener('connect', (e) => { ui.hidStatus.textContent = 'Remote connected'; e.device.open().catch(()=>{}); e.device.addEventListener('inputreport', onHidReport); });
      hid.addEventListener('disconnect', () => { ui.hidStatus.textContent = 'Remote disconnected'; });
    }
  }

  function onHidReport(event) {
    const { device, reportId, data } = event;
    const id = hidEventId(device, reportId, data);
    const hexBytes = toHexBytes(data);
    
    console.log('HID Report:', {
      device: device.productName || 'Unknown',
      reportId,
      data: hexBytes,
      id
    });
    
    // Update tester
    if (ui.keyTestLine) {
      ui.keyTestLine.textContent = `HID reportId ${reportId} (${hexBytes})`;
    }
    if (ui.keyTestDetail) {
      const midi = state.keymap[id];
      ui.keyTestDetail.textContent = midi ? `Mapped to: ${labelForMidi(midi)}` : `No mapping for: ${id}`;
    }
    
    // If mapping capture is active, assign this HID id
    if (state.waitingMapMidi !== null) {
      state.keymap[id] = state.waitingMapMidi;
      saveKeymap();
      state.waitingMapMidi = null;
      renderKeymapRows();
      setFeedback(`Mapped ${hexBytes} to ${labelForMidi(state.waitingMapMidi)}`);
      return;
    }
    
    // Otherwise, trigger if mapped
    const midi = state.keymap[id];
    if (midi != null && state.answersEnabled) {
      console.log('Triggering mapped note:', labelForMidi(midi));
      clickMidi(midi);
    }
  }

  function hidEventId(device, reportId, dataView) {
    const vid = device.vendorId?.toString(16).padStart(4,'0');
    const pid = device.productId?.toString(16).padStart(4,'0');
    const bytes = toHexBytes(dataView);
    return `hid:${vid}:${pid}:${reportId}:${bytes}`;
  }
  function toHexBytes(dv) {
    const arr = [];
    for (let i=0; i<dv.byteLength; i++) arr.push(dv.getUint8(i).toString(16).padStart(2,'0'));
    return arr.join('');
  }

  // ---------- Web Bluetooth API for direct BLE access ----------
  async function connectBluetooth() {
    if (!navigator.bluetooth) {
      ui.bluetoothStatus.textContent = 'Bluetooth not supported';
      return;
    }

    try {
      console.log('Requesting Bluetooth device...');
      ui.bluetoothStatus.textContent = 'Requesting device...';
      
      // Try specific HID devices first, then fall back to any device
      let device;
      try {
        device = await navigator.bluetooth.requestDevice({
          filters: [
            { services: ['00001812-0000-1000-8000-00805f9b34fb'] }, // HID over GATT
            { namePrefix: 'AB Shutter' },
            { namePrefix: 'Bluetooth' },
            { namePrefix: 'Remote' },
            { namePrefix: 'Shutter' },
            { namePrefix: 'BLE' },
          ],
          optionalServices: [
            '00001812-0000-1000-8000-00805f9b34fb', // HID over GATT
            '0000180f-0000-1000-8000-00805f9b34fb', // Battery Service
            '0000180a-0000-1000-8000-00805f9b34fb', // Device Information
          ]
        });
      } catch (err) {
        console.log('HID filter failed, trying broad search:', err.message);
        // Fallback: allow any device (user will need to pick manually)
        device = await navigator.bluetooth.requestDevice({
          acceptAllDevices: true,
          optionalServices: [
            '00001812-0000-1000-8000-00805f9b34fb', // HID over GATT
            '0000180f-0000-1000-8000-00805f9b34fb', // Battery Service
            '0000180a-0000-1000-8000-00805f9b34fb', // Device Information
          ]
        });
      }

      console.log('Device selected:', device.name);
      ui.bluetoothStatus.textContent = `Connecting to ${device.name}...`;
      
      state.bluetoothDevice = device;
      
      // Connect to GATT server
      const server = await device.gatt.connect();
      console.log('Connected to GATT server');
      
      // Try to find any service that might have characteristics we can use
      const services = await server.getPrimaryServices();
      console.log('Available services:', services.map(s => s.uuid));
      
      let characteristic = null;
      let allCharacteristics = [];
      
      // Collect all characteristics first
      for (const service of services) {
        try {
          console.log(`Checking service: ${service.uuid}`);
          const characteristics = await service.getCharacteristics();
          console.log(`Characteristics in ${service.uuid}:`, characteristics.map(c => ({
            uuid: c.uuid,
            properties: {
              read: c.properties.read,
              write: c.properties.write,
              notify: c.properties.notify,
              indicate: c.properties.indicate,
              writeWithoutResponse: c.properties.writeWithoutResponse
            }
          })));
          
          allCharacteristics.push(...characteristics);
          
          // Look for any characteristic that supports notifications
          for (const char of characteristics) {
            if (char.properties.notify || char.properties.indicate) {
              console.log(`Found notifiable characteristic: ${char.uuid}`);
              if (!characteristic) characteristic = char; // Use first one found
            }
          }
        } catch (err) {
          console.log(`Error with service ${service.uuid}:`, err.message);
        }
      }
      
      console.log(`Total characteristics found: ${allCharacteristics.length}`);
      console.log('All characteristics:', allCharacteristics.map(c => c.uuid));
      
      if (!characteristic) {
        throw new Error('No notifiable characteristics found');
      }
      
      state.bluetoothCharacteristic = characteristic;
      
      // Try to activate device by writing to writable characteristics
      for (const char of allCharacteristics) {
        if (char.properties.write || char.properties.writeWithoutResponse) {
          try {
            console.log(`Trying to write to characteristic: ${char.uuid}`);
            // Common activation commands for BLE devices
            const activationCommands = [
              new Uint8Array([0x01]), // Simple enable
              new Uint8Array([0x01, 0x00]), // Enable notifications
              new Uint8Array([0x00, 0x01]), // Alternative enable
              new Uint8Array([0xFF]), // Max value
            ];
            
            for (const cmd of activationCommands) {
              try {
                await char.writeValue(cmd);
                console.log(`Successfully wrote ${Array.from(cmd).map(b => b.toString(16)).join('')} to ${char.uuid}`);
                await new Promise(resolve => setTimeout(resolve, 100)); // Wait a bit
                break; // If successful, don't try other commands
              } catch (writeErr) {
                console.log(`Write failed for ${char.uuid}:`, writeErr.message);
              }
            }
          } catch (err) {
            console.log(`Error writing to ${char.uuid}:`, err.message);
          }
        }
      }
      
      // Start notifications
      await characteristic.startNotifications();
      characteristic.addEventListener('characteristicvaluechanged', onBluetoothData);
      
      ui.bluetoothStatus.textContent = `Connected: ${device.name}`;
      console.log('Bluetooth setup complete, listening for data...');
      console.log('Try pressing buttons on your device now');
      
    } catch (error) {
      console.error('Bluetooth connection error:', error);
      ui.bluetoothStatus.textContent = `Failed: ${error.message}`;
    }
  }

  function onBluetoothData(event) {
    const value = event.target.value;
    const data = new Uint8Array(value.buffer);
    const hexBytes = Array.from(data).map(b => b.toString(16).padStart(2, '0')).join('');
    
    console.log('Bluetooth data:', {
      data: hexBytes,
      length: data.length,
      values: Array.from(data)
    });
    
    // Update key tester
    if (ui.keyTestLine) {
      ui.keyTestLine.textContent = `Bluetooth data: ${hexBytes} (${data.length} bytes)`;
    }
    
    // Create unique ID based on data pattern
    const bluetoothId = `bluetooth:${hexBytes}`;
    
    if (ui.keyTestDetail) {
      const midi = state.keymap[bluetoothId];
      ui.keyTestDetail.textContent = midi ? `Mapped to: ${labelForMidi(midi)}` : `Bluetooth ID: ${bluetoothId}`;
    }
    
    // Handle mapping if active
    if (state.waitingMapMidi !== null) {
      state.keymap[bluetoothId] = state.waitingMapMidi;
      saveKeymap();
      state.waitingMapMidi = null;
      renderKeymapRows();
      setFeedback(`Mapped bluetooth data to ${labelForMidi(state.waitingMapMidi)}`);
      return;
    }
    
    
    // Check if mapped and trigger
    const midi = state.keymap[bluetoothId];
    if (midi != null && state.answersEnabled) {
      console.log('Triggering mapped note from Bluetooth:', labelForMidi(midi));
      clickMidi(midi);
    }
  }

  // ---------- Gamepad API support ----------
  function detectGamepad() {
    const gamepads = navigator.getGamepads();
    console.log('Checking for gamepads:', gamepads.length);
    
    for (let i = 0; i < gamepads.length; i++) {
      const gamepad = gamepads[i];
      if (gamepad) {
        console.log(`Gamepad ${i} found:`, {
          id: gamepad.id,
          index: gamepad.index,
          buttons: gamepad.buttons.length,
          axes: gamepad.axes.length
        });
        
        state.gamepadIndex = i;
        state.gamepadButtons = new Array(gamepad.buttons.length).fill(false);
        // Track axis states: [axis0up, axis0down, axis0left, axis0right, axis1up, axis1down, ...]
        state.gamepadAxes = new Array(gamepad.axes.length * 4).fill(false);
        ui.gamepadStatus.textContent = `Connected: ${gamepad.id} (${gamepad.buttons.length} buttons, ${gamepad.axes.length} axes)`;
        
        // Start polling
        startGamepadPolling();
        return true;
      }
    }
    
    ui.gamepadStatus.textContent = 'No gamepad detected - press a button first';
    return false;
  }
  
  function startGamepadPolling() {
    console.log('Starting gamepad polling...');
    
    function poll() {
      const gamepads = navigator.getGamepads();
      const gamepad = gamepads[state.gamepadIndex];
      
      if (!gamepad) {
        ui.gamepadStatus.textContent = 'Gamepad disconnected';
        state.gamepadIndex = -1;
        return;
      }
      
      // Check each button for state changes
      for (let i = 0; i < gamepad.buttons.length; i++) {
        const button = gamepad.buttons[i];
        const wasPressed = state.gamepadButtons[i];
        const isPressed = button.pressed;
        
        // Button press detected (transition from false to true)
        if (isPressed && !wasPressed) {
          const gamepadId = `gamepad:button${i}`;
          console.log(`Gamepad button ${i} pressed`);
          
          // Update key tester
          if (ui.keyTestLine) {
            ui.keyTestLine.textContent = `Gamepad Button ${i} pressed`;
          }
          if (ui.keyTestDetail) {
            const midi = state.keymap[gamepadId];
            ui.keyTestDetail.textContent = midi ? `Mapped to: ${labelForMidi(midi)}` : `Gamepad ID: ${gamepadId}`;
          }
          
          // Handle mapping if active
          if (state.waitingMapMidi !== null) {
            state.keymap[gamepadId] = state.waitingMapMidi;
            saveKeymap();
            state.waitingMapMidi = null;
            renderKeymapRows();
            setFeedback(`Mapped button ${i} to ${labelForMidi(state.waitingMapMidi)}`);
          } else {
            // Check if mapped and trigger
            const midi = state.keymap[gamepadId];
            if (midi != null && state.answersEnabled) {
              console.log('Triggering mapped note from gamepad:', labelForMidi(midi));
              clickMidi(midi);
            }
          }
        }
        
        state.gamepadButtons[i] = isPressed;
      }
      
      // Check axes for directional input
      for (let i = 0; i < gamepad.axes.length; i++) {
        const axisValue = gamepad.axes[i];
        const baseIndex = i * 4; // Each axis has 4 directions
        
        // Determine current axis directions
        const isUp = axisValue < -state.axisThreshold;    // Negative Y = up
        const isDown = axisValue > state.axisThreshold;   // Positive Y = down
        const isLeft = axisValue < -state.axisThreshold;  // Negative X = left  
        const isRight = axisValue > state.axisThreshold;  // Positive X = right
        
        // For even axes (0, 2, 4...) = X axis (left/right)
        // For odd axes (1, 3, 5...) = Y axis (up/down)
        const isXAxis = i % 2 === 0;
        
        if (isXAxis) {
          // X axis: check left/right
          checkAxisDirection(i, 'left', isLeft, baseIndex + 0);
          checkAxisDirection(i, 'right', isRight, baseIndex + 1);
        } else {
          // Y axis: check up/down  
          checkAxisDirection(i, 'up', isUp, baseIndex + 2);
          checkAxisDirection(i, 'down', isDown, baseIndex + 3);
        }
      }
      
      // Continue polling
      requestAnimationFrame(poll);
    }
    
    function checkAxisDirection(axisIndex, direction, isActive, stateIndex) {
      const wasActive = state.gamepadAxes[stateIndex];
      
      if (isActive && !wasActive) {
        const gamepadId = `gamepad:axis${axisIndex}-${direction}`;
        console.log(`Gamepad axis ${axisIndex} ${direction}`);
        
        // Update key tester
        if (ui.keyTestLine) {
          ui.keyTestLine.textContent = `Gamepad Axis ${axisIndex} ${direction}`;
        }
        if (ui.keyTestDetail) {
          const midi = state.keymap[gamepadId];
          ui.keyTestDetail.textContent = midi ? `Mapped to: ${labelForMidi(midi)}` : `Gamepad ID: ${gamepadId}`;
        }
        
        // Handle mapping if active
        if (state.waitingMapMidi !== null) {
          state.keymap[gamepadId] = state.waitingMapMidi;
          saveKeymap();
          state.waitingMapMidi = null;
          renderKeymapRows();
          setFeedback(`Mapped axis ${axisIndex} ${direction} to ${labelForMidi(state.waitingMapMidi)}`);
        } else {
          // Check if mapped and trigger
          const midi = state.keymap[gamepadId];
          if (midi != null && state.answersEnabled) {
            console.log('Triggering mapped note from gamepad axis:', labelForMidi(midi));
            clickMidi(midi);
          }
        }
      }
      
      state.gamepadAxes[stateIndex] = isActive;
    }
    
    poll();
  }
  
  // Gamepad connect/disconnect events
  window.addEventListener('gamepadconnected', (e) => {
    console.log('Gamepad connected:', e.gamepad.id);
    ui.gamepadStatus.textContent = `Connected: ${e.gamepad.id}`;
    detectGamepad();
  });
  
  window.addEventListener('gamepaddisconnected', (e) => {
    console.log('Gamepad disconnected:', e.gamepad.id);
    ui.gamepadStatus.textContent = 'Disconnected';
    state.gamepadIndex = -1;
  });

  // Notation toggle
  ui.solfege.addEventListener('change', () => {
    state.notation = ui.solfege.checked ? 'solfege' : 'letter';
    updatePianoLabels();
    try { localStorage.setItem('fet-notation', state.notation); } catch {}
    renderKeymapRows();
  });

  // Exercise selector
  ui.exercise.addEventListener('change', () => {
    state.exercise = Number(ui.exercise.value) || 1;
    applyScopeHighlight();
    if (state.targetMidi) {
      // reset current round to avoid mismatch with new scope
      state.targetMidi = null;
      setPianoEnabled(false);
      setRepeatEnabled(false);
      setStartEnabled(true);
      setFeedback('Exercise changed. Press Start');
    }
    renderKeymapRows();
  });

  // Repeat current target (cadence + same target)
  ui.repeatBtn.addEventListener('click', () => {
    if (!state.targetMidi) return;
    // Repeat full context: cadence + same target
    setPianoEnabled(false);
    setRepeatEnabled(false);
    setFeedback('Cadence‚Ä¶', null);
    const endCad = playCadence();
    const ctx = startAudio();
    const tTarget = endCad + 0.12;
    playTone(state.targetMidi, tTarget, 0.9, 'piano', 0.18);
    const enableAtMs = Math.max(0, (tTarget - ctx.currentTime) * 1000) + 120;
    setTimeout(() => {
      setFeedback('Identify the note (click the key)');
      setPianoEnabled(true);
      setRepeatEnabled(true);
    }, enableAtMs);
  });

  updateStats();
  setPianoEnabled(false);
  setRepeatEnabled(false);
  // Load saved notation preference
  try {
    const saved = localStorage.getItem('fet-notation');
    if (saved === 'solfege' || saved === 'letter') {
      state.notation = saved;
      ui.solfege.checked = (saved === 'solfege');
    }
  } catch {}
  buildPiano();
  setStartEnabled(false);
  setFeedback("Loading piano‚Ä¶");
  // Preload samples; onload will enable Start
  preloadSampler();
  // Reposition black keys on resize (responsive)
  window.addEventListener('resize', () => {
    positionBlackKeys();
  });
  // Load/save keymap and build UI
  loadKeymap();
  renderKeymapRows();

  // ---------- Piano UI helpers ----------
  function buildPiano() {
    const whites = [NOTES.C4, NOTES.D4, NOTES.E4, NOTES.F4, NOTES.G4, NOTES.A4, NOTES.B4, NOTES.C5];
    ui.piano.innerHTML = '';
    ui.piano.className = 'piano';
    const hasSharpAfter = (midi) => {
      // Sharps after C, D, F, G, A within the octave
      const pc = midi % 12; // 0=C, 2=D, 4=E, 5=F, 7=G, 9=A, 11=B
      return pc === 0 || pc === 2 || pc === 5 || pc === 7 || pc === 9;
    };
    // First render whites
    whites.forEach((midi) => {
      const key = document.createElement('div');
      key.className = 'key white';
      key.dataset.midi = String(midi);
      key.dataset.note = MIDI_TO_NAME[midi] || '';
      const lab = document.createElement('div');
      lab.className = 'label';
      key.appendChild(lab);
      ui.piano.appendChild(key);
    });
    // Then render blacks positioned absolutely relative to the piano container
    whites.forEach((midi) => {
      if (hasSharpAfter(midi) && midi !== NOTES.C5) { // hide C#5
        const blackMidi = midi + 1;
        const black = document.createElement('div');
        black.className = 'key black';
        black.dataset.midi = String(blackMidi);
        black.dataset.note = MIDI_TO_NAME[blackMidi] || '';
        black.dataset.blackFor = String(midi); // preceding white midi
        const blab = document.createElement('div');
        blab.className = 'label';
        black.appendChild(blab);
        ui.piano.appendChild(black);
      }
    });
    applyScopeHighlight();
    updatePianoLabels();
    positionBlackKeys();
  }

  function updatePianoLabels() {
    const useSolfege = state.notation === 'solfege';
    ui.piano.querySelectorAll('[data-midi]').forEach(el => {
      const midi = Number(el.dataset.midi);
      const pc = midi % 12;
      const text = useSolfege ? (PC_TO_SOLFEGE[pc] || '') : (PC_TO_LETTER[pc] || '');
      const lab = el.querySelector('.label');
      if (lab) lab.textContent = text;
    });
  }

  function applyScopeHighlight() {
    const allowed = new Set(getExerciseSet());
    ui.piano.querySelectorAll('.key.white').forEach(el => {
      const midi = Number(el.dataset.midi);
      el.classList.toggle('in-scope', allowed.has(midi));
      el.classList.toggle('out-of-scope', !allowed.has(midi));
    });
  }

  function labelForMidi(midi) {
    const pc = midi % 12;
    return state.notation === 'solfege' ? (PC_TO_SOLFEGE[pc] || '') : (PC_TO_LETTER[pc] || '');
  }

  function positionBlackKeys() {
    const pianoRect = ui.piano.getBoundingClientRect();
    const styles = getComputedStyle(ui.piano);
    const gap = parseFloat(styles.getPropertyValue('--gap')) || 2;
    ui.piano.querySelectorAll('.key.black').forEach(black => {
      const whiteMidi = Number(black.dataset.blackFor);
      const whiteEl = ui.piano.querySelector(`.key.white[data-midi="${whiteMidi}"]`);
      if (!whiteEl) return;
      const wRect = whiteEl.getBoundingClientRect();
      const bRect = black.getBoundingClientRect();
      const left = (wRect.left - pianoRect.left) + whiteEl.offsetWidth - (black.offsetWidth / 2) + (gap / 2);
      black.style.left = `${left}px`;
    });
  }

  // ---------- Key mapping helpers ----------
  // Deep pattern analysis for shutter buttons
  let eventHistory = [];
  let lastEventTime = 0;
  let eventCounter = 0;

  function idsFromEvent(e) {
    const ids = [];
    const k = (e.key || '').toLowerCase();
    const c = (e.code || '').toLowerCase();
    const now = performance.now();
    
    // Capture ALL possible event properties for analysis
    const eventFingerprint = {
      key: e.key,
      code: e.code,
      keyCode: e.keyCode,
      which: e.which,
      charCode: e.charCode,
      location: e.location,
      repeat: e.repeat,
      ctrlKey: e.ctrlKey,
      shiftKey: e.shiftKey,
      altKey: e.altKey,
      metaKey: e.metaKey,
      timeStamp: e.timeStamp,
      isTrusted: e.isTrusted,
      type: e.type,
      bubbles: e.bubbles,
      cancelable: e.cancelable,
      composed: e.composed
    };
    
    // Timing analysis
    const timeSinceLastEvent = now - lastEventTime;
    lastEventTime = now;
    eventCounter++;
    
    // Store event for pattern analysis
    eventHistory.push({
      ...eventFingerprint,
      timeSinceLastEvent,
      eventNumber: eventCounter
    });
    
    // Keep only last 20 events
    if (eventHistory.length > 20) {
      eventHistory = eventHistory.slice(-20);
    }
    
    // Log detailed event info for debugging
    console.log('Deep Event Analysis:', {
      eventNumber: eventCounter,
      fingerprint: eventFingerprint,
      timeSinceLastEvent: Math.round(timeSinceLastEvent),
      historyLength: eventHistory.length
    });
    
    // Handle unidentified keys with deep analysis
    if (k === 'unidentified' || k === '') {
      // Create multiple ID candidates based on different properties
      const candidates = [];
      
      // Basic properties
      if (e.keyCode) candidates.push(`keycode:${e.keyCode}`);
      if (e.which) candidates.push(`which:${e.which}`);
      if (e.charCode) candidates.push(`charcode:${e.charCode}`);
      
      // Combined properties
      const combo1 = `${e.keyCode || 0}:${e.which || 0}:${e.location || 0}`;
      candidates.push(`combo1:${combo1}`);
      
      // Timing-based (for buttons with different timing patterns)
      const timingGroup = Math.floor(timeSinceLastEvent / 50) * 50; // Group by 50ms
      candidates.push(`timing:${timingGroup}:${e.keyCode || 0}`);
      
      // Event sequence pattern (last 3 events)
      if (eventHistory.length >= 3) {
        const lastThree = eventHistory.slice(-3);
        const pattern = lastThree.map(ev => `${ev.keyCode || 0}`).join('-');
        candidates.push(`pattern3:${pattern}`);
      }
      
      // Modifier state signature
      const modifiers = `${e.ctrlKey?'C':''}${e.shiftKey?'S':''}${e.altKey?'A':''}${e.metaKey?'M':''}`;
      if (modifiers) candidates.push(`mod:${modifiers}:${e.keyCode || 0}`);
      
      // TimeStamp based (some devices have microsecond differences)
      const timestampLow = Math.floor((e.timeStamp || 0) % 1000);
      candidates.push(`ts:${timestampLow}:${e.keyCode || 0}`);
      
      ids.push(...candidates);
      
      // Also try code if available
      if (c && c !== 'unidentified') {
        ids.push(`code:${c}`);
      }
    } else {
      // Normal key handling
      if (k) { 
        ids.push(k); 
        ids.push(`key:${k}`); 
      }
    }
    
    if (c && c !== 'unidentified') { 
      ids.push(`code:${c}`); 
    }
    
    return ids;
  }
  function isReservedKeyId(id) {
    const v = id.replace(/^key:|^code:/,'');
    return ['escape','shift','control','alt','meta','tab'].includes(v);
  }
  function setKeymapFromEvent(midi, e) {
    const ids = idsFromEvent(e).filter(id => !isReservedKeyId(id));
    if (ids.length === 0) return;
    Object.keys(state.keymap).forEach(k => {
      if (state.keymap[k] === midi || ids.includes(k)) delete state.keymap[k];
    });
    const preferred = ids.find(id => id.startsWith('code:')) || ids.find(id => id.startsWith('key:')) || ids[0];
    state.keymap[preferred] = midi;
    saveKeymap();
  }
  function clearKeymap(midi) {
    Object.keys(state.keymap).forEach(k => { if (state.keymap[k] === midi) delete state.keymap[k]; });
    saveKeymap();
  }
  function saveKeymap() {
    try { localStorage.setItem('fet-keymap', JSON.stringify(state.keymap)); } catch {}
  }
  function loadKeymap() {
    try {
      const raw = localStorage.getItem('fet-keymap');
      if (raw) {
        state.keymap = JSON.parse(raw) || {};
        return;
      }
    } catch {}
    // Default home-row mapping across the visible octave: a..k
    state.keymap = { a: NOTES.C4, s: NOTES.D4, d: NOTES.E4, f: NOTES.F4, g: NOTES.G4, h: NOTES.A4, j: NOTES.B4, k: NOTES.C5 };
    saveKeymap();
  }

  function renderKeymapRows() {
    const set = getExerciseSet();
    ui.mapGrid.innerHTML = '';
    set.forEach(midi => {
      const row = document.createElement('div');
      row.className = 'map-row map-note';
      row.textContent = labelForMidi(midi);
      const setBtn = document.createElement('button');
      setBtn.className = 'btn';
      setBtn.textContent = 'Set key';
      setBtn.addEventListener('click', () => {
        state.waitingMapMidi = midi;
        setFeedback(`Press a key for ${labelForMidi(midi)} (Esc to cancel)`);
      });
      const keySpan = document.createElement('div');
      keySpan.className = 'map-key';
      keySpan.textContent = keyForMidi(midi) || '‚Äî';
      const clrBtn = document.createElement('button');
      clrBtn.className = 'btn';
      clrBtn.textContent = 'Clear';
      clrBtn.addEventListener('click', () => { clearKeymap(midi); renderKeymapRows(); });
      ui.mapGrid.appendChild(row);
      ui.mapGrid.appendChild(setBtn);
      ui.mapGrid.appendChild(keySpan);
      ui.mapGrid.appendChild(clrBtn);
    });
  }
  function keyForMidi(midi) {
    const entries = Object.entries(state.keymap).filter(([k, m]) => m === midi);
    if (entries.length === 0) return '';
    const simple = entries.find(([k]) => k.length === 1);
    const chosen = simple || entries[0];
    const id = chosen[0];
    if (id.startsWith('key:')) return id.slice(4);
    if (id.startsWith('code:')) return id.slice(5);
    return id;
  }

  // Toggle settings panel
  ui.settingsBtn.addEventListener('click', () => {
    ui.settingsPanel.classList.toggle('hidden');
    renderKeymapRows();
  });

  // Bluetooth connection
  if (ui.bluetoothConnect) {
    ui.bluetoothConnect.addEventListener('click', connectBluetooth);
  }

  // Gamepad detection
  if (ui.gamepadConnect) {
    ui.gamepadConnect.addEventListener('click', detectGamepad);
  }

  function clickMidi(midi) {
    const el = ui.piano.querySelector(`[data-midi="${midi}"]`);
    if (el) el.click();
  }

  function flashKey(el, cls, ms = 250) {
    el.classList.add('active', cls);
    setTimeout(() => el.classList.remove('active', cls), ms);
  }

  function highlightKey(midi, ms = 300) {
    const el = ui.piano.querySelector(`[data-midi="${midi}"]`);
    if (el) flashKey(el, 'hint', ms);
  }
})();
</script>
</body>
</html>
